/*
 * Copyright (c) 2024, Collins Aerospace.
 * Developed with the sponsorship of Defense Advanced Research Projects Agency (DARPA).
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this data, 
 * including any software or models in source or binary form, as well as any drawings, specifications, 
 * and documentation (collectively "the Data"), to deal in the Data without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Data, and to permit persons to whom the Data is furnished to do so, 
 * subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all copies or 
 * substantial portions of the Data.
 * 
 * THE DATA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 
 * LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
 * IN NO EVENT SHALL THE AUTHORS, SPONSORS, DEVELOPERS, CONTRIBUTORS, OR COPYRIGHT HOLDERS BE LIABLE 
 * FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE DATA OR THE USE OR OTHER DEALINGS IN THE DATA.
 *
 * Generated by Xtext version 2.33.0.
 */

package com.collins.trustedmethods.matrics.soar.serializer;

import com.collins.trustedmethods.matrics.soar.services.SoarGrammarAccess;
import com.collins.trustedmethods.matrics.soar.soar.ActionSide;
import com.collins.trustedmethods.matrics.soar.soar.AttrValueMake;
import com.collins.trustedmethods.matrics.soar.soar.AttrValueTest;
import com.collins.trustedmethods.matrics.soar.soar.Cond;
import com.collins.trustedmethods.matrics.soar.soar.CondForOneId;
import com.collins.trustedmethods.matrics.soar.soar.ConditionSide;
import com.collins.trustedmethods.matrics.soar.soar.ConjuctiveTest;
import com.collins.trustedmethods.matrics.soar.soar.Constant;
import com.collins.trustedmethods.matrics.soar.soar.DisjunctionTest;
import com.collins.trustedmethods.matrics.soar.soar.FuncCall;
import com.collins.trustedmethods.matrics.soar.soar.MultiValueTest;
import com.collins.trustedmethods.matrics.soar.soar.PositiveCond;
import com.collins.trustedmethods.matrics.soar.soar.PrefSpecifier;
import com.collins.trustedmethods.matrics.soar.soar.Print;
import com.collins.trustedmethods.matrics.soar.soar.RelationalTest;
import com.collins.trustedmethods.matrics.soar.soar.SimpleTest;
import com.collins.trustedmethods.matrics.soar.soar.SingleTest;
import com.collins.trustedmethods.matrics.soar.soar.SoarAnnexLibrary;
import com.collins.trustedmethods.matrics.soar.soar.SoarAnnexSubclause;
import com.collins.trustedmethods.matrics.soar.soar.SoarPackage;
import com.collins.trustedmethods.matrics.soar.soar.SoarProduction;
import com.collins.trustedmethods.matrics.soar.soar.StateImpCond;
import com.collins.trustedmethods.matrics.soar.soar.Test;
import com.collins.trustedmethods.matrics.soar.soar.ValueMake;
import com.collins.trustedmethods.matrics.soar.soar.ValueTest;
import com.collins.trustedmethods.matrics.soar.soar.Variable;
import com.collins.trustedmethods.matrics.soar.soar.VariableorSymConstant;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public abstract class AbstractSoarSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SoarGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SoarPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SoarPackage.ACTION:
				sequence_Action(context, (com.collins.trustedmethods.matrics.soar.soar.Action) semanticObject); 
				return; 
			case SoarPackage.ACTION_SIDE:
				sequence_ActionSide(context, (ActionSide) semanticObject); 
				return; 
			case SoarPackage.ATTR_VALUE_MAKE:
				sequence_AttrValueMake(context, (AttrValueMake) semanticObject); 
				return; 
			case SoarPackage.ATTR_VALUE_TEST:
				sequence_AttrValueTest(context, (AttrValueTest) semanticObject); 
				return; 
			case SoarPackage.COND:
				sequence_Cond(context, (Cond) semanticObject); 
				return; 
			case SoarPackage.COND_FOR_ONE_ID:
				sequence_CondForOneId(context, (CondForOneId) semanticObject); 
				return; 
			case SoarPackage.CONDITION_SIDE:
				sequence_ConditionSide(context, (ConditionSide) semanticObject); 
				return; 
			case SoarPackage.CONJUCTIVE_TEST:
				sequence_Test(context, (ConjuctiveTest) semanticObject); 
				return; 
			case SoarPackage.CONSTANT:
				sequence_Constant(context, (Constant) semanticObject); 
				return; 
			case SoarPackage.DISJUNCTION_TEST:
				sequence_DisjunctionTest(context, (DisjunctionTest) semanticObject); 
				return; 
			case SoarPackage.FUNC_CALL:
				sequence_FuncCall(context, (FuncCall) semanticObject); 
				return; 
			case SoarPackage.MULTI_VALUE_TEST:
				sequence_Test(context, (MultiValueTest) semanticObject); 
				return; 
			case SoarPackage.POSITIVE_COND:
				sequence_PositiveCond(context, (PositiveCond) semanticObject); 
				return; 
			case SoarPackage.PREF_SPECIFIER:
				sequence_PrefSpecifier(context, (PrefSpecifier) semanticObject); 
				return; 
			case SoarPackage.PRINT:
				sequence_Print(context, (Print) semanticObject); 
				return; 
			case SoarPackage.RELATIONAL_TEST:
				sequence_RelationalTest(context, (RelationalTest) semanticObject); 
				return; 
			case SoarPackage.SIMPLE_TEST:
				sequence_Test(context, (SimpleTest) semanticObject); 
				return; 
			case SoarPackage.SINGLE_TEST:
				sequence_SingleTest(context, (SingleTest) semanticObject); 
				return; 
			case SoarPackage.SOAR_ANNEX_LIBRARY:
				sequence_SoarAnnexLibrary(context, (SoarAnnexLibrary) semanticObject); 
				return; 
			case SoarPackage.SOAR_ANNEX_SUBCLAUSE:
				sequence_SoarAnnexSubclause(context, (SoarAnnexSubclause) semanticObject); 
				return; 
			case SoarPackage.SOAR_PRODUCTION:
				sequence_SoarProduction(context, (SoarProduction) semanticObject); 
				return; 
			case SoarPackage.STATE_IMP_COND:
				sequence_StateImpCondition(context, (StateImpCond) semanticObject); 
				return; 
			case SoarPackage.TEST:
				sequence_Test(context, (Test) semanticObject); 
				return; 
			case SoarPackage.VALUE_MAKE:
				sequence_ValueMake(context, (ValueMake) semanticObject); 
				return; 
			case SoarPackage.VALUE_TEST:
				sequence_ValueTest(context, (ValueTest) semanticObject); 
				return; 
			case SoarPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			case SoarPackage.VARIABLEOR_SYM_CONSTANT:
				sequence_VariableorSymConstant(context, (VariableorSymConstant) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     ActionSide returns ActionSide
	 *
	 * Constraint:
	 *     (action+=Action | funcCall+=FuncCall | print+=Print)*
	 * </pre>
	 */
	protected void sequence_ActionSide(ISerializationContext context, ActionSide semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Action returns Action
	 *
	 * Constraint:
	 *     (variable=Variable attrValMake+=AttrValueMake+)
	 * </pre>
	 */
	protected void sequence_Action(ISerializationContext context, com.collins.trustedmethods.matrics.soar.soar.Action semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AttrValueMake returns AttrValueMake
	 *
	 * Constraint:
	 *     (variableOrSymConstant+=VariableorSymConstant variableOrSymConstant+=VariableorSymConstant* valueMake+=ValueMake*)
	 * </pre>
	 */
	protected void sequence_AttrValueMake(ISerializationContext context, AttrValueMake semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AttrValueTest returns AttrValueTest
	 *
	 * Constraint:
	 *     (attrTest+=SYM_CONSTANT_STRING attrTest+=SYM_CONSTANT_STRING* valueTest+=ValueTest*)
	 * </pre>
	 */
	protected void sequence_AttrValueTest(ISerializationContext context, AttrValueTest semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CondForOneId returns CondForOneId
	 *
	 * Constraint:
	 *     (idTest=Variable attrValueTest+=AttrValueTest+)
	 * </pre>
	 */
	protected void sequence_CondForOneId(ISerializationContext context, CondForOneId semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Cond returns Cond
	 *
	 * Constraint:
	 *     cond=PositiveCond
	 * </pre>
	 */
	protected void sequence_Cond(ISerializationContext context, Cond semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SoarPackage.Literals.COND__COND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SoarPackage.Literals.COND__COND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCondAccess().getCondPositiveCondParserRuleCall_2_0(), semanticObject.getCond());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ConditionSide returns ConditionSide
	 *
	 * Constraint:
	 *     (stateImpCondition=StateImpCondition cond+=Cond*)
	 * </pre>
	 */
	protected void sequence_ConditionSide(ISerializationContext context, ConditionSide semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Value returns Constant
	 *     Constant returns Constant
	 *
	 * Constraint:
	 *     {Constant}
	 * </pre>
	 */
	protected void sequence_Constant(ISerializationContext context, Constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DisjunctionTest returns DisjunctionTest
	 *
	 * Constraint:
	 *     constant+=Constant+
	 * </pre>
	 */
	protected void sequence_DisjunctionTest(ISerializationContext context, DisjunctionTest semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FuncCall returns FuncCall
	 *     Value returns FuncCall
	 *
	 * Constraint:
	 *     value+=Value*
	 * </pre>
	 */
	protected void sequence_FuncCall(ISerializationContext context, FuncCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PositiveCond returns PositiveCond
	 *
	 * Constraint:
	 *     (condForOneId=CondForOneId | cond+=Cond+)
	 * </pre>
	 */
	protected void sequence_PositiveCond(ISerializationContext context, PositiveCond semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PrefSpecifier returns PrefSpecifier
	 *
	 * Constraint:
	 *     (unaryPref=UnaryPref | (unaryOrBinaryPref=UnaryOrBinaryPref value=Value?))
	 * </pre>
	 */
	protected void sequence_PrefSpecifier(ISerializationContext context, PrefSpecifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Print returns Print
	 *
	 * Constraint:
	 *     variable+=Variable*
	 * </pre>
	 */
	protected void sequence_Print(ISerializationContext context, Print semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RelationalTest returns RelationalTest
	 *
	 * Constraint:
	 *     (singleTest=SingleTest | singleTest=SingleTest)
	 * </pre>
	 */
	protected void sequence_RelationalTest(ISerializationContext context, RelationalTest semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SingleTest returns SingleTest
	 *
	 * Constraint:
	 *     (variable=Variable | constant=Constant)
	 * </pre>
	 */
	protected void sequence_SingleTest(ISerializationContext context, SingleTest semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AnnexLibrary returns SoarAnnexLibrary
	 *     SoarAnnexLibrary returns SoarAnnexLibrary
	 *
	 * Constraint:
	 *     soarAnnexProductions+=SoarProduction*
	 * </pre>
	 */
	protected void sequence_SoarAnnexLibrary(ISerializationContext context, SoarAnnexLibrary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AnnexSubclause returns SoarAnnexSubclause
	 *     SoarAnnexSubclause returns SoarAnnexSubclause
	 *
	 * Constraint:
	 *     soarAnnexProductions+=SoarProduction*
	 * </pre>
	 */
	protected void sequence_SoarAnnexSubclause(ISerializationContext context, SoarAnnexSubclause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SoarProduction returns SoarProduction
	 *
	 * Constraint:
	 *     (name=SYM_CONSTANT_STRING doc=Documentation? flag=Flags? conditions=ConditionSide actions=ActionSide)
	 * </pre>
	 */
	protected void sequence_SoarProduction(ISerializationContext context, SoarProduction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StateImpCondition returns StateImpCond
	 *
	 * Constraint:
	 *     (idTest=Variable? attrValueTest+=AttrValueTest+)
	 * </pre>
	 */
	protected void sequence_StateImpCondition(ISerializationContext context, StateImpCond semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Test returns ConjuctiveTest
	 *
	 * Constraint:
	 *     disjunctionTest=DisjunctionTest
	 * </pre>
	 */
	protected void sequence_Test(ISerializationContext context, ConjuctiveTest semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SoarPackage.Literals.CONJUCTIVE_TEST__DISJUNCTION_TEST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SoarPackage.Literals.CONJUCTIVE_TEST__DISJUNCTION_TEST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTestAccess().getDisjunctionTestDisjunctionTestParserRuleCall_0_2_0(), semanticObject.getDisjunctionTest());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Test returns MultiValueTest
	 *
	 * Constraint:
	 *     {MultiValueTest}
	 * </pre>
	 */
	protected void sequence_Test(ISerializationContext context, MultiValueTest semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Test returns SimpleTest
	 *
	 * Constraint:
	 *     disjunctionTest=DisjunctionTest
	 * </pre>
	 */
	protected void sequence_Test(ISerializationContext context, SimpleTest semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SoarPackage.Literals.SIMPLE_TEST__DISJUNCTION_TEST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SoarPackage.Literals.SIMPLE_TEST__DISJUNCTION_TEST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTestAccess().getDisjunctionTestDisjunctionTestParserRuleCall_2_1_0(), semanticObject.getDisjunctionTest());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Test returns Test
	 *
	 * Constraint:
	 *     (relationalTest=RelationalTest | relationalTest=RelationalTest)
	 * </pre>
	 */
	protected void sequence_Test(ISerializationContext context, Test semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ValueMake returns ValueMake
	 *
	 * Constraint:
	 *     (value=Value prefSpecifier+=PrefSpecifier*)
	 * </pre>
	 */
	protected void sequence_ValueMake(ISerializationContext context, ValueMake semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ValueTest returns ValueTest
	 *
	 * Constraint:
	 *     (test=Test | condForOneId=CondForOneId)
	 * </pre>
	 */
	protected void sequence_ValueTest(ISerializationContext context, ValueTest semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Variable returns Variable
	 *     Value returns Variable
	 *
	 * Constraint:
	 *     {Variable}
	 * </pre>
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     VariableorSymConstant returns VariableorSymConstant
	 *
	 * Constraint:
	 *     variable=Variable?
	 * </pre>
	 */
	protected void sequence_VariableorSymConstant(ISerializationContext context, VariableorSymConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
