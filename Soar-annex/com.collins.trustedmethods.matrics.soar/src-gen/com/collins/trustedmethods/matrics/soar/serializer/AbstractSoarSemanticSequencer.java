/*
 * Copyright (c) 2023, Collins Aerospace.
 * Developed with the sponsorship of Defense Advanced Research Projects Agency (DARPA).
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this data, 
 * including any software or models in source or binary form, as well as any drawings, specifications, 
 * and documentation (collectively "the Data"), to deal in the Data without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Data, and to permit persons to whom the Data is furnished to do so, 
 * subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all copies or 
 * substantial portions of the Data.
 * 
 * THE DATA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 
 * LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
 * IN NO EVENT SHALL THE AUTHORS, SPONSORS, DEVELOPERS, CONTRIBUTORS, OR COPYRIGHT HOLDERS BE LIABLE 
 * FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE DATA OR THE USE OR OTHER DEALINGS IN THE DATA.
 *
 * Generated by Xtext version 2.25.0.
 */

package com.collins.trustedmethods.matrics.soar.serializer;

import com.collins.trustedmethods.matrics.soar.services.SoarGrammarAccess;
import com.collins.trustedmethods.matrics.soar.soar.ActionSideExpr;
import com.collins.trustedmethods.matrics.soar.soar.AttrValueTest;
import com.collins.trustedmethods.matrics.soar.soar.BinaryExpr;
import com.collins.trustedmethods.matrics.soar.soar.CommaExpr;
import com.collins.trustedmethods.matrics.soar.soar.ConjunctTestExpr;
import com.collins.trustedmethods.matrics.soar.soar.ConstStringExpr;
import com.collins.trustedmethods.matrics.soar.soar.CrlfExpr;
import com.collins.trustedmethods.matrics.soar.soar.DisjunctTestExpr;
import com.collins.trustedmethods.matrics.soar.soar.MultiValTestExpr;
import com.collins.trustedmethods.matrics.soar.soar.ParenExpr;
import com.collins.trustedmethods.matrics.soar.soar.PrefSpecifierExpr;
import com.collins.trustedmethods.matrics.soar.soar.SoarAnnexLibrary;
import com.collins.trustedmethods.matrics.soar.soar.SoarAnnexSubclause;
import com.collins.trustedmethods.matrics.soar.soar.SoarPackage;
import com.collins.trustedmethods.matrics.soar.soar.SoarProduction;
import com.collins.trustedmethods.matrics.soar.soar.StateImpCond;
import com.collins.trustedmethods.matrics.soar.soar.StringExpr;
import com.collins.trustedmethods.matrics.soar.soar.SymConstExpr;
import com.collins.trustedmethods.matrics.soar.soar.UnaryExpr;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public abstract class AbstractSoarSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SoarGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SoarPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SoarPackage.ACTION_SIDE_EXPR:
				sequence_ActionSideExpr(context, (ActionSideExpr) semanticObject); 
				return; 
			case SoarPackage.ATTR_VALUE_TEST:
				sequence_AttrValueTest(context, (AttrValueTest) semanticObject); 
				return; 
			case SoarPackage.BINARY_EXPR:
				if (rule == grammarAccess.getConditionExprRule()
						|| rule == grammarAccess.getPlusExprRule()
						|| action == grammarAccess.getPlusExprAccess().getBinaryExprLeftAction_1_0_0_0()) {
					sequence_PlusExpr_RelationalExpr(context, (BinaryExpr) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRelationalExprRule()) {
					sequence_RelationalExpr(context, (BinaryExpr) semanticObject); 
					return; 
				}
				else break;
			case SoarPackage.COMMA_EXPR:
				sequence_ActionExpr(context, (CommaExpr) semanticObject); 
				return; 
			case SoarPackage.CONJUNCT_TEST_EXPR:
				sequence_AtomicConditionExpr(context, (ConjunctTestExpr) semanticObject); 
				return; 
			case SoarPackage.CONST_STRING_EXPR:
				sequence_AtomicConditionExpr(context, (ConstStringExpr) semanticObject); 
				return; 
			case SoarPackage.CRLF_EXPR:
				sequence_ActionExpr(context, (CrlfExpr) semanticObject); 
				return; 
			case SoarPackage.DISJUNCT_TEST_EXPR:
				sequence_AtomicConditionExpr(context, (DisjunctTestExpr) semanticObject); 
				return; 
			case SoarPackage.MULTI_VAL_TEST_EXPR:
				sequence_AtomicConditionExpr(context, (MultiValTestExpr) semanticObject); 
				return; 
			case SoarPackage.PAREN_EXPR:
				sequence_ActionExpr(context, (ParenExpr) semanticObject); 
				return; 
			case SoarPackage.PREF_SPECIFIER_EXPR:
				sequence_ActionExpr(context, (PrefSpecifierExpr) semanticObject); 
				return; 
			case SoarPackage.SOAR_ANNEX_LIBRARY:
				sequence_SoarAnnexLibrary(context, (SoarAnnexLibrary) semanticObject); 
				return; 
			case SoarPackage.SOAR_ANNEX_SUBCLAUSE:
				sequence_SoarAnnexSubclause(context, (SoarAnnexSubclause) semanticObject); 
				return; 
			case SoarPackage.SOAR_PRODUCTION:
				sequence_SoarProduction(context, (SoarProduction) semanticObject); 
				return; 
			case SoarPackage.STATE_IMP_COND:
				sequence_StateImpCondition(context, (StateImpCond) semanticObject); 
				return; 
			case SoarPackage.STRING_EXPR:
				sequence_ActionExpr(context, (StringExpr) semanticObject); 
				return; 
			case SoarPackage.SYM_CONST_EXPR:
				if (rule == grammarAccess.getActionExprRule()) {
					sequence_ActionExpr(context, (SymConstExpr) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getConditionExprRule()
						|| rule == grammarAccess.getPlusExprRule()
						|| action == grammarAccess.getPlusExprAccess().getBinaryExprLeftAction_1_0_0_0()
						|| rule == grammarAccess.getRelationalExprRule()
						|| action == grammarAccess.getRelationalExprAccess().getBinaryExprLeftAction_1_0_0_0()
						|| rule == grammarAccess.getPrefixExprRule()
						|| rule == grammarAccess.getAtomicConditionExprRule()) {
					sequence_AtomicConditionExpr(context, (SymConstExpr) semanticObject); 
					return; 
				}
				else break;
			case SoarPackage.UNARY_EXPR:
				sequence_PrefixExpr(context, (UnaryExpr) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ActionExpr returns CommaExpr
	 *
	 * Constraint:
	 *     {CommaExpr}
	 */
	protected void sequence_ActionExpr(ISerializationContext context, CommaExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ActionExpr returns CrlfExpr
	 *
	 * Constraint:
	 *     {CrlfExpr}
	 */
	protected void sequence_ActionExpr(ISerializationContext context, CrlfExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ActionExpr returns ParenExpr
	 *
	 * Constraint:
	 *     exprs+=ActionExpr+
	 */
	protected void sequence_ActionExpr(ISerializationContext context, ParenExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ActionExpr returns PrefSpecifierExpr
	 *
	 * Constraint:
	 *     {PrefSpecifierExpr}
	 */
	protected void sequence_ActionExpr(ISerializationContext context, PrefSpecifierExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ActionExpr returns StringExpr
	 *
	 * Constraint:
	 *     (val=SYM_CONSTANT_STRING | expr=PIPE_STRING)
	 */
	protected void sequence_ActionExpr(ISerializationContext context, StringExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ActionExpr returns SymConstExpr
	 *
	 * Constraint:
	 *     val=SymConstant
	 */
	protected void sequence_ActionExpr(ISerializationContext context, SymConstExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SoarPackage.Literals.SYM_CONST_EXPR__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SoarPackage.Literals.SYM_CONST_EXPR__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getActionExprAccess().getValSymConstantParserRuleCall_0_0_1_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ActionSideExpr returns ActionSideExpr
	 *
	 * Constraint:
	 *     ((id=SymConstant makeId=SYM_CONSTANT_STRING attrValMakes+=ActionExpr+) | text+=ActionExpr+)
	 */
	protected void sequence_ActionSideExpr(ISerializationContext context, ActionSideExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConditionExpr returns ConjunctTestExpr
	 *     PlusExpr returns ConjunctTestExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns ConjunctTestExpr
	 *     RelationalExpr returns ConjunctTestExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns ConjunctTestExpr
	 *     PrefixExpr returns ConjunctTestExpr
	 *     AtomicConditionExpr returns ConjunctTestExpr
	 *
	 * Constraint:
	 *     tests+=ConditionExpr*
	 */
	protected void sequence_AtomicConditionExpr(ISerializationContext context, ConjunctTestExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConditionExpr returns ConstStringExpr
	 *     PlusExpr returns ConstStringExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns ConstStringExpr
	 *     RelationalExpr returns ConstStringExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns ConstStringExpr
	 *     PrefixExpr returns ConstStringExpr
	 *     AtomicConditionExpr returns ConstStringExpr
	 *
	 * Constraint:
	 *     val=SYM_CONSTANT_STRING
	 */
	protected void sequence_AtomicConditionExpr(ISerializationContext context, ConstStringExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SoarPackage.Literals.CONST_STRING_EXPR__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SoarPackage.Literals.CONST_STRING_EXPR__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicConditionExprAccess().getValSYM_CONSTANT_STRINGTerminalRuleCall_4_1_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ConditionExpr returns DisjunctTestExpr
	 *     PlusExpr returns DisjunctTestExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns DisjunctTestExpr
	 *     RelationalExpr returns DisjunctTestExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns DisjunctTestExpr
	 *     PrefixExpr returns DisjunctTestExpr
	 *     AtomicConditionExpr returns DisjunctTestExpr
	 *
	 * Constraint:
	 *     consts+=ConditionExpr+
	 */
	protected void sequence_AtomicConditionExpr(ISerializationContext context, DisjunctTestExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConditionExpr returns MultiValTestExpr
	 *     PlusExpr returns MultiValTestExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns MultiValTestExpr
	 *     RelationalExpr returns MultiValTestExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns MultiValTestExpr
	 *     PrefixExpr returns MultiValTestExpr
	 *     AtomicConditionExpr returns MultiValTestExpr
	 *
	 * Constraint:
	 *     tests+=ConditionExpr+
	 */
	protected void sequence_AtomicConditionExpr(ISerializationContext context, MultiValTestExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConditionExpr returns SymConstExpr
	 *     PlusExpr returns SymConstExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns SymConstExpr
	 *     RelationalExpr returns SymConstExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns SymConstExpr
	 *     PrefixExpr returns SymConstExpr
	 *     AtomicConditionExpr returns SymConstExpr
	 *
	 * Constraint:
	 *     val=SymConstant
	 */
	protected void sequence_AtomicConditionExpr(ISerializationContext context, SymConstExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SoarPackage.Literals.SYM_CONST_EXPR__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SoarPackage.Literals.SYM_CONST_EXPR__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicConditionExprAccess().getValSymConstantParserRuleCall_3_1_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AttrValueTest returns AttrValueTest
	 *
	 * Constraint:
	 *     (attrTest+=SYM_CONSTANT_STRING attrTest+=SYM_CONSTANT_STRING* test=ConditionExpr)
	 */
	protected void sequence_AttrValueTest(ISerializationContext context, AttrValueTest semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConditionExpr returns BinaryExpr
	 *     PlusExpr returns BinaryExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns BinaryExpr
	 *
	 * Constraint:
	 *     ((left=PlusExpr_BinaryExpr_1_0_0_0 op='+' right=RelationalExpr) | (left=RelationalExpr_BinaryExpr_1_0_0_0 op=RelationalOp right=PrefixExpr))
	 */
	protected void sequence_PlusExpr_RelationalExpr(ISerializationContext context, BinaryExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConditionExpr returns UnaryExpr
	 *     PlusExpr returns UnaryExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns UnaryExpr
	 *     RelationalExpr returns UnaryExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns UnaryExpr
	 *     PrefixExpr returns UnaryExpr
	 *
	 * Constraint:
	 *     (op='-' expr=PrefixExpr)
	 */
	protected void sequence_PrefixExpr(ISerializationContext context, UnaryExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SoarPackage.Literals.UNARY_EXPR__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SoarPackage.Literals.UNARY_EXPR__OP));
			if (transientValues.isValueTransient(semanticObject, SoarPackage.Literals.UNARY_EXPR__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SoarPackage.Literals.UNARY_EXPR__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrefixExprAccess().getOpHyphenMinusKeyword_0_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getPrefixExprAccess().getExprPrefixExprParserRuleCall_0_2_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RelationalExpr returns BinaryExpr
	 *
	 * Constraint:
	 *     (left=RelationalExpr_BinaryExpr_1_0_0_0 op=RelationalOp right=PrefixExpr)
	 */
	protected void sequence_RelationalExpr(ISerializationContext context, BinaryExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SoarPackage.Literals.BINARY_EXPR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SoarPackage.Literals.BINARY_EXPR__LEFT));
			if (transientValues.isValueTransient(semanticObject, SoarPackage.Literals.BINARY_EXPR__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SoarPackage.Literals.BINARY_EXPR__OP));
			if (transientValues.isValueTransient(semanticObject, SoarPackage.Literals.BINARY_EXPR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SoarPackage.Literals.BINARY_EXPR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelationalExprAccess().getBinaryExprLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getRelationalExprAccess().getOpRelationalOpParserRuleCall_1_0_0_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getRelationalExprAccess().getRightPrefixExprParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AnnexLibrary returns SoarAnnexLibrary
	 *     SoarAnnexLibrary returns SoarAnnexLibrary
	 *
	 * Constraint:
	 *     soarAnnexProductions+=SoarProduction*
	 */
	protected void sequence_SoarAnnexLibrary(ISerializationContext context, SoarAnnexLibrary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AnnexSubclause returns SoarAnnexSubclause
	 *     SoarAnnexSubclause returns SoarAnnexSubclause
	 *
	 * Constraint:
	 *     soarAnnexProductions+=SoarProduction*
	 */
	protected void sequence_SoarAnnexSubclause(ISerializationContext context, SoarAnnexSubclause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SoarProduction returns SoarProduction
	 *
	 * Constraint:
	 *     (name=SYM_CONSTANT_STRING doc=Documentation? flag=Flags? conditions+=StateImpCondition* actions+=ActionSideExpr+)
	 */
	protected void sequence_SoarProduction(ISerializationContext context, SoarProduction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StateImpCondition returns StateImpCond
	 *
	 * Constraint:
	 *     (id=SymConstant attrValueTest+=AttrValueTest+)
	 */
	protected void sequence_StateImpCondition(ISerializationContext context, StateImpCond semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
